import os
import json
import threading
import time
from typing import Any, Dict, List, Optional, Tuple
import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext, ttk
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from fpdf import FPDF
CONFIG_FILE = "invoice_dispatch_app.json"
def load_config() -> Dict[str, Any]:
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            pass
    return {
        "mark_invoiced_url": "",     # <- leave blank for dry-run; or point to your own API
        "extra_headers_json": "{}",  # JSON dict string for extra headers if needed
        "default_status": "DISPATCH",
        "default_limit": 4,
        "default_offset": 4,
        "default_sort": "desc",
    }
def save_config(cfg: Dict[str, Any]) -> None:
    try:
        with open(CONFIG_FILE, "w", encoding="utf-8") as f:
            json.dump(cfg, f, indent=2)
    except Exception:
        pass
class APIClient:
    def __init__(self, auth_token: str, timeout: int = 30, retries: int = 3, backoff: float = 0.5):
        self.base_orders = "https://api.virtualstock.com/restapi/v4/orders/"
        self.base_suppliers = "https://www.the-edge.io/restapi/v4/suppliers/"
        self.session = requests.Session()
        self.session.headers.update({
            "Authorization": f"Basic {auth_token}",
            "Accept": "application/json",
            "Content-Type": "application/json",
            "User-Agent": "HN-InvoiceApp/1.1"
        })
        self.timeout = timeout
        retry = Retry(
            total=retries,
            read=retries,
            connect=retries,
            backoff_factor=backoff,
            status_forcelist=(429, 500, 502, 503, 504),
            allowed_methods=frozenset(["GET", "POST"]),
            raise_on_status=False,
        )
        adapter = HTTPAdapter(max_retries=retry)
        self.session.mount("https://", adapter)
        self.session.mount("http://", adapter)
    def get(self, url: str, **kwargs) -> requests.Response:
        resp = self.session.get(url, timeout=self.timeout, **kwargs)
        resp.raise_for_status()
        return resp
    def post(self, url: str, json_body: dict, headers: Optional[dict] = None) -> requests.Response:
        hdrs = dict(self.session.headers)
        if headers:
            hdrs.update(headers)
        resp = self.session.post(url, json=json_body, headers=hdrs, timeout=self.timeout)
        resp.raise_for_status()
        return resp
    def fetch_orders(self, status: str = "DISPATCH", limit: int = 4, offset: int = 0, sort: str = "desc") -> Dict[str, Any]:
        params = {"status": status, "limit": limit, "offset": offset, "sort": sort}
        r = self.get(self.base_orders, params=params)
        return r.json()
    def fetch_supplier_details(self, supplier_id: str) -> Dict[str, Any]:
        url = f"{self.base_suppliers}{supplier_id}/"
        r = self.get(url)
        return r.json()
from fpdf import FPDF
class ProInvoicePDF(FPDF):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.margin_l = 12
        self.margin_r = 12
        self.margin_t = 15
        self.margin_b = 15
        self.set_margins(self.margin_l, self.margin_t, self.margin_r)
        self.set_auto_page_break(auto=True, margin=self.margin_b)
    def header(self):
        self.set_font("Helvetica", "B", 16)
        self.cell(0, 8, "TAX INVOICE", ln=1, align="C")
        self.set_draw_color(210, 210, 210)
        self.ln(2)
        self.line(self.margin_l, self.get_y(), self.w - self.margin_r, self.get_y())
        self.ln(4)
    def footer(self):
        self.set_y(-12)
        self.set_font("Helvetica", "I", 8)
        self.set_text_color(120, 120, 120)
        self.cell(0, 8, "Generated by Dispatched Invoice Generator", 0, 0, "C")
        self.set_text_color(0, 0, 0)
def _money(x):
    try:
        return f"{float(x):.2f}"
    except Exception:
        return "0.00"
def export_invoice_pdf_pro(inv, save_path: str) -> None:
    pdf = ProInvoicePDF(orientation="P", unit="mm", format="A4")
    pdf.add_page()
    page_w = pdf.w - pdf.margin_l - pdf.margin_r
    gutter = 6
    col_w = (page_w - gutter) / 2
    def add_kv(label: str, value: str, lw=36, lh=6):
        pdf.set_font("Helvetica", "B", 10); pdf.cell(lw, lh, f"{label}:", 0, 0)
        pdf.set_font("Helvetica", "", 10);  pdf.cell(0, lh, str(value), 0, 1)
    def card(title: str, party: dict, x: float, y: float, w: float) -> float:
        """Returns the card height actually used."""
        pdf.set_xy(x, y)
        pdf.set_draw_color(230, 230, 230)
        pdf.set_line_width(0.2)
        inner_x = x + 3
        inner_y = y + 3
        pdf.set_xy(inner_x, inner_y)
        pdf.set_font("Helvetica", "B", 11)
        pdf.cell(w - 6, 6, title, ln=1)
        pdf.set_font("Helvetica", "", 10)
        pdf.set_x(inner_x); pdf.multi_cell(w - 6, 5, party.get("company_name", "-"))
        addr = party.get("address", {}) or {}
        addr_line = " ".join(filter(None, [addr.get("line_1",""), addr.get("city",""),
                                           addr.get("state",""), addr.get("postal_code","")]))
        if addr_line:
            pdf.set_x(inner_x); pdf.multi_cell(w - 6, 5, addr_line)
        pe_lines = []
        if party.get("phone"): pe_lines.append(f"Phone: {party.get('phone')}")
        if party.get("email"): pe_lines.append(f"Email: {party.get('email')}")
        for ln in pe_lines:
            pdf.set_x(inner_x); pdf.cell(w - 6, 5, ln, ln=1)
        h = pdf.get_y() - inner_y + 3
        pdf.rect(x, y, w, h)
        return h
    def table_header(x: float, widths, th=7):
        pdf.set_xy(x, pdf.get_y())
        pdf.set_font("Helvetica", "B", 10)
        headers = ["Item", "Qty", "Unit Cost", "Line Total"]
        aligns  = ["L",   "R",   "R",        "R"]
        for i, htxt in enumerate(headers):
            pdf.cell(widths[i], th, htxt, border=1, align=aligns[i])
        pdf.ln(th)
        pdf.set_font("Helvetica", "", 10)
    def table_row(x: float, widths, row, th=7):
        """
        Multi-line name cell, lock-step row height for other cells.
        """
        name = str(row.get("name",""))
        qty  = str(row.get("quantity", 0))
        unit = _money(row.get("unit_cost_price", 0))
        total= _money(row.get("total", 0))
        min_row_h = th
        if pdf.get_y() + (min_row_h * 2) > (pdf.h - pdf.margin_b):
            pdf.add_page()
            table_header(x, widths, th)
        x0, y0 = pdf.get_x(), pdf.get_y()
        pdf.set_xy(x, y0)
        pdf.multi_cell(widths[0], th, name, border=1)  # this advances Y
        h = pdf.get_y() - y0  # real row height
        pdf.set_xy(x + widths[0], y0); pdf.cell(widths[1], h, qty,   border=1, align="R")
        pdf.set_xy(x + widths[0] + widths[1], y0); pdf.cell(widths[2], h, unit,  border=1, align="R")
        pdf.set_xy(x + widths[0] + widths[1] + widths[2], y0); pdf.cell(widths[3], h, total, border=1, align="R")
        pdf.set_xy(x0, y0 + h)
    pdf.set_font("Helvetica", "B", 12)
    pdf.cell(0, 6, f"Invoice #: {inv.get('invoice_number','')}", ln=1)
    pdf.set_font("Helvetica", "", 10)
    pdf.cell(0, 6, f"Invoice Date: {inv.get('invoice_date','')}", ln=1)
    pdf.cell(0, 6, f"Currency: {inv.get('currency','AUD')}", ln=1)
    pdf.ln(2)
    y_parties = pdf.get_y()
    left_h  = card("From", inv.get("bill_from", {}), pdf.margin_l, y_parties, col_w)
    right_h = card("To",   inv.get("bill_to",   {}), pdf.margin_l + col_w + gutter, y_parties, col_w)
    pdf.set_y(y_parties + max(left_h, right_h) + 4)
    pdf.set_font("Helvetica", "B", 11)
    pdf.cell(0, 6, "Order Details", ln=1)
    pdf.set_font("Helvetica", "", 10)
    od = inv.get("order_details", {}) or {}
    add_kv("Order Ref",     od.get("order_reference", ""))
    add_kv("Additional Ref",od.get("additional_order_reference", ""))
    add_kv("End User PO",   od.get("end_user_purchase_order_reference",""))
    add_kv("Dispatch Date", od.get("dispatch_date",""))
    if od.get("comment"):
        pdf.multi_cell(0, 6, f"Comment: {od['comment']}")
    pdf.ln(2)
    x_table = pdf.margin_l
    widths = [page_w * 0.55, page_w * 0.12, page_w * 0.16, page_w * 0.17]
    widths[-1] = page_w - sum(widths[:-1])
    table_header(x_table, widths, th=7)
    items = inv.get("items", [])
    if not items:
        items = [{"name": "Goods", "quantity": 1, "unit_cost_price": 0.0, "total": 0.0}]
    for it in items:
        table_row(x_table, widths, it, th=7)
    pdf.ln(2)
    totals = inv.get("totals", {}) or {}
    rows = [
        ("Subtotal",    _money(totals.get("subtotal", 0))),
        ("Freight",     _money(totals.get("freight", 0))),
        ("Tax",         _money(totals.get("tax", 0))),
        ("Grand Total", _money(totals.get("grand_total", 0))),
    ]
    totals_w = 70
    if pdf.get_y() + 35 > (pdf.h - pdf.margin_b):  # ensure space for totals + note
        pdf.add_page()
    x_tot = pdf.margin_l + page_w - totals_w
    line_h = 7
    for i, (label, val) in enumerate(rows):
        pdf.set_xy(x_tot, pdf.get_y())
        bold = "B" if label == "Grand Total" else ""
        pdf.set_font("Helvetica", bold, 10 if not bold else 11)
        pdf.cell(totals_w - 30, line_h, label, border=1)
        pdf.cell(30, line_h, val, border=1, align="R")
        pdf.ln(line_h)
    note = "Note: Please contact accounts within 7 days for any discrepancies."
    if pdf.get_y() + 10 > (pdf.h - pdf.margin_b):
        pdf.add_page()
    pdf.ln(3)
    pdf.set_font("Helvetica", "I", 9)
    pdf.set_text_color(90, 90, 90)
    pdf.multi_cell(0, 5, note)
    pdf.set_text_color(0, 0, 0)
    pdf.output(save_path)
class InvoiceApp:
    def __init__(self, root: tk.Tk):
        self.root = root
        self.root.title("PDF Invoice Generator")
        self.cfg = load_config()
        self.last_invoice_data: Optional[Dict[str, Any]] = None
        self.batch_invoices: List[Dict[str, Any]] = []
        outer = ttk.PanedWindow(root, orient=tk.HORIZONTAL)
        outer.pack(fill=tk.BOTH, expand=True)
        sidebar = ttk.Frame(outer, width=320, padding=10)
        main = ttk.Frame(outer, padding=10)
        outer.add(sidebar, weight=0)
        outer.add(main, weight=1)
        r = 0
        ttk.Label(sidebar, text="Auth Token (Basic ...)").grid(row=r, column=0, sticky="w"); r += 1
        self.auth_entry = ttk.Entry(sidebar, width=40, show="*")
        self.auth_entry.grid(row=r, column=0, sticky="ew", pady=(0,6)); r += 1
        api_box = ttk.LabelFrame(sidebar, text="Fetch Options")
        api_box.grid(row=r, column=0, sticky="ew"); r += 1
        ttk.Label(api_box, text="Status").grid(row=0, column=0, sticky="w")
        self.status_var = tk.StringVar(value=self.cfg.get("default_status","DISPATCH"))
        ttk.Combobox(api_box, textvariable=self.status_var,
                     values=["ORDER","PROCESS","DISPATCH","CANCEL"], width=12, state="readonly").grid(row=0, column=1, sticky="ew")
        ttk.Label(api_box, text="Limit").grid(row=1, column=0, sticky="w")
        self.limit_var = tk.StringVar(value=str(self.cfg.get("default_limit", 4)))
        ttk.Entry(api_box, textvariable=self.limit_var, width=10).grid(row=1, column=1, sticky="ew")
        ttk.Label(api_box, text="Offset").grid(row=2, column=0, sticky="w")
        self.offset_var = tk.StringVar(value=str(self.cfg.get("default_offset", 4)))
        ttk.Entry(api_box, textvariable=self.offset_var, width=10).grid(row=2, column=1, sticky="ew")
        ttk.Label(api_box, text="Sort").grid(row=3, column=0, sticky="w")
        self.sort_var = tk.StringVar(value=self.cfg.get("default_sort","desc"))
        ttk.Combobox(api_box, textvariable=self.sort_var,
                     values=["asc","desc"], width=12, state="readonly").grid(row=3, column=1, sticky="ew")
        ttk.Separator(sidebar).grid(row=r, column=0, sticky="ew", pady=6); r += 1
        hook_box = ttk.LabelFrame(sidebar, text="Mark as Invoiced (Optional)")
        hook_box.grid(row=r, column=0, sticky="ew"); r += 1
        ttk.Label(hook_box, text="Endpoint URL").grid(row=0, column=0, sticky="w")
        self.hook_url_var = tk.StringVar(value=self.cfg.get("mark_invoiced_url",""))
        ttk.Entry(hook_box, textvariable=self.hook_url_var, width=40).grid(row=1, column=0, sticky="ew", pady=(0,4))
        ttk.Label(hook_box, text="Extra Headers (JSON)").grid(row=2, column=0, sticky="w")
        self.extra_headers_var = tk.StringVar(value=self.cfg.get("extra_headers_json","{}"))
        ttk.Entry(hook_box, textvariable=self.extra_headers_var, width=40).grid(row=3, column=0, sticky="ew")
        self.chk_mark_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(hook_box, text="Call endpoint after each successful PDF", variable=self.chk_mark_var).grid(row=4, column=0, sticky="w", pady=(6,0))
        ttk.Separator(sidebar).grid(row=r, column=0, sticky="ew", pady=6); r += 1
        ttk.Button(sidebar, text="Fetch Orders", command=self.fetch_orders_threaded).grid(row=r, column=0, sticky="ew"); r += 1
        ttk.Button(sidebar, text="Export Last Invoice (PDF)", command=self.export_last_pdf).grid(row=r, column=0, sticky="ew", pady=(4,0)); r += 1
        ttk.Button(sidebar, text="Bulk Export All (one PDF per order)", command=self.bulk_export_threaded).grid(row=r, column=0, sticky="ew", pady=(4,0)); r += 1
        sidebar.columnconfigure(0, weight=1)
        self.output = scrolledtext.ScrolledText(main, width=100, height=36)
        self.output.pack(fill=tk.BOTH, expand=True)
        self.status = ttk.Label(main, text="Ready", anchor="w")
        self.status.pack(fill=tk.X, pady=(6, 0))
        self.progress = ttk.Progressbar(main, mode="determinate", maximum=100)
        self.progress.pack(fill=tk.X)
        self.root.minsize(1000, 640)
    def log(self, text: str):
        self.output.insert(tk.END, text + "\n")
        self.output.see(tk.END)
    def set_status(self, text: str):
        self.status.config(text=text)
        self.status.update_idletasks()
    def _parse_int(self, s: str, default: int) -> int:
        try: return int(s)
        except Exception: return default
    def _supplier_id_from_url(self, url: str) -> Optional[str]:
        if not url: return None
        parts = url.strip().rstrip("/").split("/")
        if parts and parts[-1].isdigit(): return parts[-1]
        if len(parts) >= 2 and parts[-2].isdigit(): return parts[-2]
        return None
    def fetch_orders_threaded(self):
        threading.Thread(target=self._fetch_orders, daemon=True).start()
    def _fetch_orders(self):
        auth = self.auth_entry.get().strip()
        if not auth:
            messagebox.showerror("Error", "Provide the Auth Token.")
            return
        status = self.status_var.get().strip() or "DISPATCH"
        limit = self._parse_int(self.limit_var.get(), 4)
        offset = self._parse_int(self.offset_var.get(), 4)
        sort = self.sort_var.get().strip() or "desc"
        client = APIClient(auth_token=auth)
        self.set_status(f"Fetching: status={status}, limit={limit}, offset={offset}, sort={sort}")
        self.progress["value"] = 0
        try:
            payload = client.fetch_orders(status=status, limit=limit, offset=offset, sort=sort)
        except Exception as e:
            messagebox.showerror("Fetch Error", str(e)); return
        results: List[Dict[str, Any]] = payload.get("results", [])
        if not results:
            self.log("No orders found.")
            self.set_status("No results")
            return
        self.batch_invoices.clear()
        for i, order in enumerate(results, start=1):
            inv = self._build_invoice_dict(client, order)
            self.batch_invoices.append(inv)
            self.last_invoice_data = inv
            self.log(f"Prepared invoice for {inv['order_details']['order_reference']} → {inv['invoice_number']}")
            pct = int((i / len(results)) * 100)
            self.progress["value"] = pct
            self.set_status(f"Prepared {i}/{len(results)} ({pct}%)")
        self.log(json.dumps({"count": payload.get("count", 0),
                             "next": bool(payload.get("next")), "previous": bool(payload.get("previous"))}, indent=2))
        self.set_status("Ready to export")
        self.cfg["mark_invoiced_url"] = self.hook_url_var.get().strip()
        self.cfg["extra_headers_json"] = self.extra_headers_var.get().strip()
        save_config(self.cfg)
    def _build_invoice_dict(self, client: APIClient, order: Dict[str, Any]) -> Dict[str, Any]:
        order_reference = str(order.get("order_reference", ""))
        supplier_id = self._supplier_id_from_url(order.get("supplier",""))
        currency = order.get("currency_code", "AUD")
        order_date = (order.get("order_date") or "0000-00-00").split("T")[0]
        add_ref = order.get("additional_order_reference") or ""
        end_user_ref = order.get("end_user_purchase_order_reference") or ""
        comment = order.get("comment") or ""
        items_raw = order.get("items") or []
        if items_raw:
            item0 = items_raw[0]
            item = {
                "name": str(item0.get("name") or item0.get("part_number") or "Goods"),
                "quantity": int(float(item0.get("quantity", 0) or 0)),
                "unit_cost_price": float(item0.get("unit_cost_price", 0) or 0),
                "tax": float(item0.get("tax", 0) or 0),
                "total": float(item0.get("total", 0) or 0),
            }
        else:
            item = {"name": "Goods", "quantity": 1, "unit_cost_price": 0.0, "tax": 0.0, "total": 0.0}
        subtotal = float(order.get("subtotal", 0) or 0)
        tax = float(order.get("tax", 0) or 0)
        grand_total = float(order.get("total", subtotal + tax) or 0)
        retailer = order.get("retailer_data") or {}
        retailer_name = retailer.get("name") or "Harvey Norman Marketplace"
        bill_to = {
            "company_name": retailer_name,
            "address": {
                "line_1": "145-151 Arthur Street",
                "city": "Homebush West",
                "state": "NSW",
                "postal_code": "2140"
            },
            "phone": "+61 2 9999 8888",
            "email": "orders@harveynorman.com.au"
        }
        bill_from = {"company_name": "Supplier", "address": {"line_1": "", "city": "", "state": "", "postal_code": ""}, "phone": "", "email": ""}
        if supplier_id:
            try:
                supplier = client.fetch_supplier_details(supplier_id)
                bill_from["company_name"] = supplier.get("name") or "Supplier"
                addr = supplier.get("address") or {}
                bill_from["address"] = {
                    "line_1": addr.get("line_1", "") or "",
                    "city": addr.get("city", "") or "",
                    "state": addr.get("state", "") or "",
                    "postal_code": addr.get("postal_code", "") or ""
                }
                bill_from["phone"] = supplier.get("phone", "") or ""
                bill_from["email"] = supplier.get("email", "") or ""
            except Exception as e:
                self.log(f"[WARN] Supplier fetch failed for {supplier_id}: {e}")
        inv_prefix = order_reference.split("_")[0] if "_" in order_reference else order_reference[-6:]
        invoice_number = f"INV-{inv_prefix}"
        return {
            "invoice_number": invoice_number,
            "invoice_date": order_date,
            "currency": currency,
            "bill_from": bill_from,
            "bill_to": bill_to,
            "order_details": {
                "order_reference": order_reference,
                "additional_order_reference": add_ref,
                "end_user_purchase_order_reference": end_user_ref,
                "dispatch_date": order_date,
                "comment": comment
            },
            "items": [item],
            "totals": {
                "subtotal": subtotal,
                "freight": 0.0,
                "tax": tax,
                "grand_total": grand_total
            }
        }
    def export_last_pdf(self):
        if not self.last_invoice_data:
            messagebox.showerror("Error", "No invoice prepared. Fetch orders first.")
            return
        suggested = f"{self.last_invoice_data.get('invoice_number','invoice')}.pdf"
        path = filedialog.asksaveasfilename(defaultextension=".pdf",
                                            filetypes=[("PDF files", "*.pdf")],
                                            initialfile=suggested)
        if not path: return
        try:
            export_invoice_pdf_pro(self.last_invoice_data, path)
            self.log(f"Saved PDF → {path}")
            self._maybe_mark_invoiced(self.last_invoice_data)
        except Exception as e:
            messagebox.showerror("Export Error", str(e))
    def bulk_export_threaded(self):
        threading.Thread(target=self._bulk_export, daemon=True).start()
    def _bulk_export(self):
        if not self.batch_invoices:
            messagebox.showerror("Error", "No invoices prepared. Fetch orders first.")
            return
        folder = filedialog.askdirectory(title="Choose export folder")
        if not folder: return
        self.cfg["mark_invoiced_url"] = self.hook_url_var.get().strip()
        self.cfg["extra_headers_json"] = self.extra_headers_var.get().strip()
        save_config(self.cfg)
        total = len(self.batch_invoices)
        ok_count = 0
        self.progress["value"] = 0
        self.set_status(f"Exporting {total} PDFs…")
        for i, inv in enumerate(self.batch_invoices, start=1):
            fn = f"{inv['invoice_number']}.pdf"
            path = os.path.join(folder, fn)
            try:
                export_invoice_pdf_pro(inv, path)
                ok_count += 1
                self.log(f"[OK] {inv['order_details']['order_reference']} → {fn}")
                self._maybe_mark_invoiced(inv)
            except Exception as e:
                self.log(f"[ERROR] Failed {inv['order_details']['order_reference']} → {e}")
            pct = int((i / total) * 100)
            self.progress["value"] = pct
            self.set_status(f"Exported {i}/{total} ({pct}%)")
            self.root.update_idletasks()
        self.set_status(f"Done. {ok_count}/{total} PDFs saved.")
    def _maybe_mark_invoiced(self, inv: Dict[str, Any]):
        if not self.chk_mark_var.get():
            return
        url = self.hook_url_var.get().strip()
        if not url:
            self.log("[DRY-RUN] No mark_invoiced_url set; skipping notify.")
            return
        extra_hdrs: Dict[str, str] = {}
        try:
            extra_hdrs = json.loads(self.extra_headers_var.get().strip() or "{}")
            if not isinstance(extra_hdrs, dict):
                extra_hdrs = {}
        except Exception:
            extra_hdrs = {}
        body = {
            "order_reference": inv["order_details"]["order_reference"],
            "invoice_number": inv["invoice_number"],
            "total": inv["totals"]["grand_total"],
            "currency": inv.get("currency", "AUD"),
        }
        threading.Thread(target=self._post_mark_invoiced_safe, args=(url, body, extra_hdrs), daemon=True).start()
    def _post_mark_invoiced_safe(self, url: str, body: Dict[str, Any], extra_hdrs: Dict[str, str]):
        auth = self.auth_entry.get().strip()
        client = APIClient(auth_token=auth)
        try:
            r = client.post(url, json_body=body, headers=extra_hdrs)
            self.log(f"[MARKED] {body['order_reference']} as invoiced → {r.status_code}")
        except Exception as e:
            self.log(f"[WARN] Mark invoiced failed for {body['order_reference']}: {e}")
if __name__ == "__main__":
    root = tk.Tk()
    style = ttk.Style()
    if "clam" in style.theme_names():
        style.theme_use("clam")
    app = InvoiceApp(root)
    root.mainloop()
